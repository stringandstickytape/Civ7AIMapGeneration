[This file contains supporting information generated by AI]
 In the Civ7 mapping framework there are six “map types” (for example, Archipelago, Continents, Continents‑Plus, Fractal, Terra‑Incognita, and Shuffle) that—all despite their differences—share the same underlying API. The API is broken up into several modules (or “namespaces”) that provide functions to (1) query the map geometry and game information, (2) work with global constants and tuning parameters, (3) generate fractal noise and terrain (elevation, mountains, hills, lakes, rivers), (4) “decorate” the land with biomes, natural features, resources and discoveries, and (5) find and assign start positions. This guide describes each module’s functions and global variables, giving you the datatype of parameters and return values as well as usage notes and examples.

─────────────────────────────  
1. CORE MAP GENERATOR INTERFACE  
─────────────────────────────  
Every map–script (archipelago.js, continents.js, etc.) defines at minimum two functions that are called by the engine:  

A. requestMapData(initParams: Object)  
 • Purpose: When the engine asks for “map–init data”, this function logs parameters (such as width, height, top/bottom latitude, and wrap flags) then passes the data on via a call to engine.call.  
 • Parameters:  
  – initParams: an object containing properties  
   • width (number)  
   • height (number)  
   • topLatitude (number)  
   • bottomLatitude (number)  
   • wrapX (boolean)  
   • wrapY (boolean)  
   • mapSize (number or string, as looked up from GameInfo.Maps)  
 • Usage Example:  
  requestMapData({width:800, height:600, topLatitude:85, bottomLatitude:–85, wrapX:true, wrapY:false, mapSize:3});

B. generateMap()  
 • Purpose: This is the primary “entry‐point” that builds/processes the map. It typically:  
  – Retrieves dimensions from GameplayMap (getGridWidth, getGridHeight, getMapSize)  
  – Sets up “continental” boundaries (objects with {west, east, south, north, continent})  
  – Calls one or more routines (often from imported modules) to “carve out” landmasses from an initial water–world; then fixes coasts; then adds mountains, hills, rivers, lakes, features, biomes, natural wonders, and resources; and finally assigns start positions and discoveries.
 • Parameters: None  
 • Return Value: none  
 • Usage Example:  
  generateMap()  
  (the function is normally registered with engine.on('GenerateMap', generateMap))

C. Registration with the engine  
 Every script ends with statements such as:  
  engine.on('RequestMapInitData', requestMapData);  
  engine.on('GenerateMap', generateMap);  
 This tells the game engine which functions to call at the proper times.

─────────────────────────────  
2. CORE GLOBALS – (map–globals.js)  
─────────────────────────────  
These exported globals are numeric constants (typically indexes into the game’s database) and tuning parameters used across the map–generation code.

Example globals (all are numbers unless noted):

• g_MountainTerrain  
 – Type: number (index into GameInfo.Terrains)  
 – Definition: The terrain index for “TERRAIN_MOUNTAIN”.  
 – Usage: TerrainBuilder.setTerrainType(x,y, g_MountainTerrain)

• g_HillTerrain  
 – Type: number – “TERRAIN_HILL”.

• g_FlatTerrain  
 – Type: number – “TERRAIN_FLAT”.

• g_CoastTerrain  
 – Type: number – “TERRAIN_COAST”.

• g_OceanTerrain  
 – Type: number – “TERRAIN_OCEAN”.

• g_NavigableRiverTerrain  
 – Type: number – “TERRAIN_NAVIGABLE_RIVER”.

Biomes:  
• g_TundraBiome, g_GrasslandBiome, g_PlainsBiome, g_TropicalBiome, g_DesertBiome, g_MarineBiome  
 – Type: number (each is an index into GameInfo.Biomes)

Features:  
• g_VolcanoFeature  
 – Type: number – index for volcanoes (GameInfo.Features entry “FEATURE_VOLCANO”).

Other tuning variables (all type number):  
• g_GrasslandLatitude, g_PlainsLatitude, g_DesertLatitude, g_TropicalLatitude  
 – These store maximum latitude values as provided by the Biomes definitions.

• g_LandmassFractal, g_MountainFractal, g_HillFractal  
 – Type: number  
 – These are IDs used when calling FractalBuilder.create(…).

• g_PolarWaterRows (number): e.g. 2 rows of water along south and north edges  
• g_OceanWaterColumns (number): e.g. 4 columns of water along the sides

Shape and weighting parameters for fractal and landmass generation:  
• g_FractalWeight (number; typically 0.8)  
• g_WaterPercent (number; e.g. 20)  
• g_IgnoreStartSectorPctFromCtr (number; e.g. 93)  
• g_StartSectorWeight (number; e.g. 0.5)  
• g_CenterWeight (number; e.g. 0.7)  
• g_CenterExponent (number; e.g. 1.3)  
• g_Cutoff (number; e.g. 2.0)  
• g_AvoidSeamOffset (number; e.g. 2)  
• g_IslandWidth (number; e.g. 5)

Rainfall/floodplain parameters:  
• g_StandardRainfall (number; e.g. 100)  
• g_MountainTopIncrease (number; e.g. 100)  
• g_RainShadowDrop (number; e.g. –80)  
• g_RainShadowIncreasePerHex (number; e.g. 10)

Start–position buffers:  
• g_RequiredBufferBetweenMajorStarts (number; e.g. 6)  
• g_DesiredBufferBetweenMajorStarts (number; e.g. 12)  
• g_RequiredDistanceFromMajorForDiscoveries (number; e.g. 3)

All these globals are used by almost every phase of map production.

─────────────────────────────  
3. MAP UTILITIES – (map-utilities.js)  
─────────────────────────────  
These helper functions perform calculations to decide positional adjustments, “sector” computations, and so on.

• needHumanNearEquator()  
 – Returns: boolean  
 – Description: Loops through alive players to see if any human’s bias (via StartBias settings) calls for a “Tropical” start.  
 – Usage: if (needHumanNearEquator()) { … }

• getDistanceFromContinentCenter(iX:number, iY:number, iContinentBottomRow:number, iContinentTopRow:number, iWestContinentLeftCol:number, iWestContinentRightCol:number, iEastContinentLeftCol:number, iEastContinentRightCol:number): number  
 – Returns: number (distance in “plot–units”)  
 – Usage: let d = getDistanceFromContinentCenter(10, 15, 2, 58, 5, 40, 45, 80);

• getMaxDistanceFromContinentCenter(iX:number, iContinentBottomRow:number, iContinentTopRow:number, iWestContinentLeftCol:number, iWestContinentRightCol:number, iEastContinentLeftCol:number, iEastContinentRightCol:number): number

• getSector(iX:number, iY:number, iRows:number, iCols:number, iContinentBottomRow:number, iContinentTopRow:number, iWestContinentLeftCol:number, iWestContinentRightCol:number, iEastContinentLeftCol:number): number  
 – Returns: number (a sector index within the continent grid)  
 – Usage: let sector = getSector(x, y, 3, 4, south, north, west1, east1, west2);

• getSectorRegion(iSector:number, iRows:number, iCols:number, iContinentBottomRow:number, iContinentTopRow:number, iWestContinentLeftCol:number, iWestContinentRightCol:number, iEastContinentLeftCol:number): Object  
 – Returns: an object with properties {west:number, east:number, south:number, north:number, continent:number}  
 – Usage: let region = getSectorRegion(5, 3, 4, …);

• getHeightAdjustingForStartSector(iX:number, iY:number, iWaterHeight:number, iFractalWeight:number, iCenterWeight:number, iStartSectorWeight:number, continent1:Object, continent2:Object, iStartSectorRows:number, iStartSectorCols:number, startSectors:Array): number  
 – Returns: computed “height” (number) for plot (x,y). This value is based on the base fractal height plus bonuses when a plot is near the continent’s center or within a “start sector.”

• createIslands(iWidth:number, iHeight:number, continent1:Object, continent2:Object, iSize:number)  
 – Usage: creates additional groups of islands using a fractal of given “iSize.”

• shuffle(array:Array): Array  
 – Shuffles an array in place (returns the same array shuffled).  
 – Usage: let newArray = shuffle(oldArray);

• getContinentEdgeHeightBump(iX:number, iY:number): number  
 – Returns a “bump” amount (number) if the tile is near a secondary continent (i.e. if GameplayMap.findSecondContinent is true).

• getDistanceToClosestStart(iX:number, iY:number, numFoundEarlier:number, startPositions:Array<number>): number  
 – Returns: number (minimum plot–distance from the given plot to any plot in startPositions)  
 – Usage: let d = getDistanceToClosestStart(x, y, startPositions.length, startPositions);

• addLandmassPlotTags(iX:number, iY:number, iEastContinentLeftCol:number): void  
 – Call: For a land plot, adds tags indicating it belongs to the “LANDMASS” and also sets either “WEST_LANDMASS” or “EAST_LANDMASS” depending on whether x is less than iEastContinentLeftCol.  
 – Usage: addLandmassPlotTags(x,y, eastContinent.west);

• addWaterPlotTags(iX:number, iY:number, iEastContinentLeftCol:number): void  
 – Similar purpose as above, but for water plots.

• adjustOceanPlotTags(bWestSide:boolean): void  
 – Iterates over the entire map and ensures that all water (and lake) plots have appropriate “PLOT_TAG_WATER” together with either “WEST_WATER” or “EAST_WATER” depending on the passed-in bias.

• isAdjacentToNaturalWonder(iX:number, iY:number): boolean  
 – Checks if any directly adjacent plot (via all directions) contains a natural wonder.

• isCliff(iX:number, iY:number): boolean  
 – Returns true if any adjacent direction is not a “cliff crossing” (indicating a sudden elevation change).

• isOceanAccess(iX:number, iY:number): boolean  
 – Returns true if any adjacent plot’s river or water area connects to the ocean.

• isAdjacentToLand(iX:number, iY:number): boolean  
 – Returns true if the current plot or any neighbor has the “ISLAND” plot tag.

─────────────────────────────  
4. MAP DEBUG HELPERS – (map-debug-helpers.js)  
─────────────────────────────  
These functions “dump” an ASCII representation of various layers onto the log for debugging purposes. All functions take iWidth (number) and iHeight (number) and output console.log strings.

• dumpStartSectors(sectors: Array<boolean>): void  
 – Iterates over the given sectors array and logs each sector index and value.

• dumpContinents(iWidth:number, iHeight:number): void  
 – Prints an ASCII map of continent indexes for each plot (using GameplayMap.getContinentType).

• dumpTerrain(iWidth:number, iHeight:number): void  
 – Prints an ASCII map of terrain based on:  
  – “.” for Flat, “^” for Hill, “M” for Mountain, “~” for Ocean.

• dumpElevation(iWidth:number, iHeight:number): void  
 – Prints the elevation values (divided by 100) for each non–water tile.

• dumpRainfall(iWidth:number, iHeight:number): void  
 – Displays rainfall values (or symbols such as “D” for high, “s” for standard).

• dumpBiomes(iWidth:number, iHeight:number): void  
 – Prints a map of biomes (using simple characters, e.g. “_” for Plains, “*” for Tundra, “#” for Tropical, etc.) plus a summary count per biome.

• dumpFeatures(iWidth:number, iHeight:number): void  
 – Prints an ASCII map of features using a lookup table that maps a Feature index to a character (for example, “M” for Marsh, “F” for Forest, “@” for a wonder).

• dumpResources(iWidth:number, iHeight:number): void  
 – Prints resource indexes (or “*” on land with no resource) along with a count summary.

• dumpNoisePredicate(iWidth:number, iHeight:number, noise:Array<number>, pred:(val:number)=>string): void  
 – Iterates over a noise array (typically produced by TerrainBuilder.generatePoissonMap) and prints the output of the provided predicate function (which converts a numeric noise value into a character).

─────────────────────────────  
5. TERRAIN/ ELEVATION GENERATION – (elevation-terrain-generator.js)  
─────────────────────────────  

Functions (all typically have the signature (iWidth:number, iHeight:number) and sometimes additional parameters):

• addMountains(iWidth:number, iHeight:number): void  
 – Creates fractal noise using FractalBuilder for mountains and hills, then sets any plot’s terrain to g_MountainTerrain if its fractal “height” exceeds a threshold  
 – The threshold is computed from a “mountains percentage” (modified by World Age and, optionally, a live event bonus).  
 – Usage: addMountains(width, height);

• addHills(iWidth:number, iHeight:number): void  
 – For each non–water, non–mountain tile, computes a “hill score” based on differences in elevation from its six neighbors.  
 – If the score exceeds a threshold (dependent on World Age and extra parameters), the tile is set to g_HillTerrain.

• expandCoasts(iWidth:number, iHeight:number): void  
 – Iterates over every plot; for water plots that are adjacent to “shallow water” (detected by GameplayMap.isAdjacentToShallowWater) and that meet a random chance check, changes the terrain to g_CoastTerrain.  
 – Usage: expandCoasts(width, height);

• generateLakes(iWidth:number, iHeight:number, iTilesPerLake:number): void  
 – Iterates over non–water, non–coastal, passable plots and, with a probability determined by “ilakePlotRand” (based on total map area divided by iTilesPerLake), “grows” a lake by calling addMoreLake on that plot.  
 – Usage: generateLakes(width, height, lakeFrequency);

• buildRainfallMap(iWidth:number, iHeight:number): void  
 – For every non–water tile, computes a rainfall value based on the plot’s elevation and distance from a “mountain”.  
 – Sets rainfall on the tile via TerrainBuilder.setRainfall.

─────────────────────────────  
6. FEATURE AND BIOME GENERATION – (feature-biome-generator.js)  
─────────────────────────────

Two main functions:

• designateBiomes(iWidth:number, iHeight:number): void  
 – Iterates over every plot: if water, sets the biome to g_MarineBiome; if land, uses the plot’s latitude (adjusted by elevation and proximity to rivers) to decide among biomes (Plains, Tropical, Desert, Grassland, or Tundra).  
 – The decision uses global latitude thresholds (g_TropicalLatitude, g_PlainsLatitude, etc.) and “lowering” adjustments computed from overall land distribution.  
 – Usage: designateBiomes(width, height);

• addFeatures(iWidth:number, iHeight:number): void  
 – Performs “positional” placement first by scanning every non–water plot and, based on its “coastal” or “near river” status, attempts to place a feature (from GameInfo.Features) using its defined “PlacementDensity.”
 – Then calls scatterFeatures(iWidth, iHeight) which further randomly “sprinkles” additional features onto eligible plots.
 – Also calls addIce(iWidth, iHeight) and addReefs(iWidth, iHeight) for special water‐adjacent features.
 – Usage: addFeatures(width, height);

Additional helper (internal to the module) is canAddFeature(…) which checks whether a particular feature may be added at a location (based on the “PlacementClass” and conditions).

─────────────────────────────  
7. NATURAL WONDER GENERATION – (natural-wonder-generator.js)  
─────────────────────────────

Primary function:  

• addNaturalWonders(iWidth:number, iHeight:number, iNumNaturalWonders:number, wonderEventActive?:boolean): void  
 – Checks that the number requested does not exceed the total number available  
 – Logs the count then calls an internal routine (placeWonders) to distribute “top–priority” (PlaceFirst==true) and then “regular” natural wonders.
 – In the placement loops it iterates over each plot and uses testers such as TerrainBuilder.canHaveFeature and checks for “second continent” conditions.
 – Usage: addNaturalWonders(width, height, numWonders, true/false);

─────────────────────────────  
8. RESOURCE GENERATION – (resource-generator.js)  
─────────────────────────────

Primary function:  

• generateResources(iWidth:number, iHeight:number, continent1:Object, continent2:Object, iNumWest:number, iNumEast:number): void  
 – First determines an “east bias” based on the number of players on each side  
 – Then builds up an array of valid resource types (from GameInfo.Resources) that are “tradeable” and allowed in the current start–age.  
 – It generates a Poisson noise map (via TerrainBuilder.generatePoissonMap) to “sprinkle” candidate plots.  
 – For any plot meeting the noise threshold it builds a list of resource types valid for the location. The checking calls canHaveFlowerPlot(…) (which in turn calls ResourceBuilder.canHaveResource).  
 – It then selects the resource type with the highest “running weight” (adjusted by randomness) and calls ResourceBuilder.setResourceType at that plot.
 – Usage: generateResources(width, height, continentObject1, continentObject2, numPlayersWest, numPlayersEast);

Helper functions inside include:  
• canHaveFlowerPlot(iX, iY, resourceType:number): boolean  
• getFlowerPlot(iX, iY, resourceType:number): number  (returns a plot index, or –1 if none available)

─────────────────────────────  
9. VOLCANO GENERATION – (volcano-generator.js)  
─────────────────────────────

Primary function:  

• addVolcanoes(iWidth:number, iHeight:number): void  
 – Iterates over every non–water plot. For each plot it counts how many adjacent mountains (via getNumberAdjacentMountains) and then tests if the plot is “near” a boundary between continents (using GameplayMap.findSecondContinent with distance parameters).  
 – With a chance that depends on “boundary closeness” and a lookup table (iMountainPercentByDistance), the tile is either turned into a volcano (by setting its terrain to g_MountainTerrain and then calling TerrainBuilder.setFeatureType(x, y, {Feature: g_VolcanoFeature,…})) or, if not chosen for a volcano, then in some cases its mountain probability is increased.
 – Usage: addVolcanoes(width, height);

Helper functions include:  
• getNumberAdjacentMountains(iX, iY): number  
• getNumberAdjacentVolcanoes(iX, iY): number

─────────────────────────────  
10. SNOW GENERATION – (snow-generator.js)  
─────────────────────────────

Two main functions:

• generateSnow(iWidth:number, iHeight:number): void  
 – “Permanent snow” is applied near the poles. It computes a “snow line” based on desired latitude (for example, 60°) and then iterates over rows starting from the polar water rows until that row limit. For each plot that is not water, it rolls random chances – and depending on the roll it “adds” a snow effect from one of three categories (light, medium, heavy).  
 – Snow effects are applied via MapPlotEffects.addPlotEffect.  
 – Usage: generateSnow(width, height);

• dumpPermanentSnow(iWidth:number, iHeight:number): void  
 – Debug routine. Prints an ASCII “map” of snow effects: “@” for heavy, “#” for medium, “*” for light, “.” for none.
 – Usage: dumpPermanentSnow(width, height);

─────────────────────────────  
11. DISCOVERY GENERATION – (discovery-generator.js)  
─────────────────────────────

Primary function:  

• generateDiscoveries(iWidth:number, iHeight:number, startingPositions:Array<number>): void  
 – Uses a Poisson noise map (via TerrainBuilder.generatePoissonMap) with average distance ~5 and smoothing 2.  
 – For each plot meeting the noise threshold (noise value ≥ 1) it checks if it is too close to any player start (using getDistanceToClosestStart) or already owned. If the terrain is passable and devoid of natural resources (or already a natural wonder, etc.) then it “rolls” to decide on a discovery type.  
 – Different “visual” representations are chosen depending on the starting Age (e.g. Exploration vs. Antiquity) via helper functions DiscoveryDiceRoller( ), DiscoveryVisualString( ) and DiscoveryVisualHash( ).  
 – Finally it calls MapConstructibles.addDiscovery(x, y, discoveryHash, discoveryActivationType) and logs success.
 – Usage: generateDiscoveries(width, height, startPositions);

─────────────────────────────  
12. START POSITION ASSIGNMENT  
There are two modules for start positioning:

A. assign-starting-plots.js  
 • chooseStartSectors(iNumPlayersLandmass1:number, iNumPlayersLandmass2:number, iRows:number, iCols:number, bHumanNearEquator:boolean): Array<boolean>  
  – Returns an array (length = sectors per continent * 2) where “true” indicates that the sector is “selected” as a valid start sector.
 • assignStartPositions(iNumWest:number, iNumEast:number, west:Object, east:Object, iStartSectorRows:number, iStartSectorCols:number, sectors:Array<boolean>): Array<number>  
  – Returns an array of starting plot indices. The order of the array does not necessarily correspond to the player’s ID.  
  – Usage: startPositions = assignStartPositions(numPlayersWest, numPlayersEast, westContinent, eastContinent, startSectorRows, startSectorCols, startSectors);

B. assign-advanced-start-region.js  
 • assignAdvancedStartRegions(): void  
  – Goes through all alive players, builds an “advanced start region” for each (taking into account leader and civilization biases), iteratively “claims” plots (using a scoring system) until the region is built and then sets it via StartPositioner.setAdvancedStartRegion(player, claimedPlots).
  – Usage (called at the end of generateMap): assignAdvancedStartRegions();

─────────────────────────────  
13. COMMON ENGINE OBJECTS AND FUNCTIONS  
In addition to the modules above, the map generator scripts have access to several game–engine objects. These are not defined inside the Lua/JS files themselves but are available at runtime:

A. GameplayMap  
 Methods include (all take numbers, return numbers or booleans):  
  – getGridWidth(): number  
  – getGridHeight(): number  
  – getMapSize(): number  
  – getPlotLatitude(x:number, y:number): number  
  – getTerrainType(x:number, y:number): number  
  – isWater(x, y): boolean  
  – isMountain(x, y): boolean  
  – isCoastalLand(x, y): boolean  
  – isRiver(x, y): boolean  
  – isCliffCrossing(x, y, direction:number): boolean  
  – getElevation(x, y): number  
  – getPlotDistance(x1,y1,x2,y2): number  
  – getIndexFromXY(x,y): number  
  – getLocationFromIndex(index: number): { x: number, y: number }  
  – getOwner(x,y): number (or special constant such as PlayerIds.NO_PLAYER)  
  – getAreaId(x,y): number  
  – isAdjacentToShallowWater(x,y): boolean  
  – findSecondContinent(x,y, distance): boolean or a value  
  – getHemisphere(x: number): number (typically, 0 for one hemisphere, 1 for the other)

B. TerrainBuilder  
 • setTerrainType(x:number, y:number, terrain:number): void  
 • setPlotTag(x:number,y:number, tag:number): void  
 • addPlotTag(x,y, tag:number): void  
 • removePlotTag(x,y, tag:number): void  
 • getRandomNumber(max:number, context:string): number  
  – Returns a random integer between 0 and max–1. The “context” string is used for debugging.  
 • generatePoissonMap(seed:number, avgDistanceBetweenPoints:number, normalizedRangeSmoothing:number): Array<number>  
  – Returns a one–dimensional array (of length = map width * map height) holding noise values (number).  
 • defineNamedRivers(): void  
 • storeWaterData(): void  
 • modelRivers(param1:number, param2:number, navigableTerrain:number): void

C. FractalBuilder  
 • create(fractalID:number, width:number, height:number, size:number, flags:number): void  
  – Creates fractal data used later to “cut” the landmass.  
 • getHeightFromPercent(fractalID:number, percent:number): number  
  – Given a desired “water percentage” (or other percent) returns a numeric threshold.  
 • getHeight(fractalID:number, x:number, y:number): number

D. AreaBuilder  
 • recalculateAreas(): void  
  – Reconstructs “areas” (for connectivity of water/land) after terrain changes.  
 • isAreaConnectedToOcean(areaId:number): boolean

E. Others  
 • MapConstructibles, ResourceBuilder, MapPlotEffects, MapRivers, FertilityBuilder  
  – These objects provide functions for:  
   – Adding discoveries (MapConstructibles.addDiscovery(x,y, discoveryVisual, discoveryActivationType): boolean)  
   – Checking and placing resources (ResourceBuilder.canHaveResource(…), ResourceBuilder.setResourceType(…))  
   – Adding visual plot effects (MapPlotEffects.getPlotEffectTypesContainingTags([…]), addPlotEffect(index, effectID), hasPlotEffect(index, effectID))  
   – Checking river connectivity (MapRivers.isRiverConnectedToOcean(plotIndex): boolean)  
   – Recalculating fertility (FertilityBuilder.recalculate())

F. Engine  
 • on(eventName:string, callback:Function): void  
  – Registers a function to be called when the given event (such as “GenerateMap”) is triggered.

G. GameInfo  
 • Contains definitions for Ages, Maps, Civilizations, Leaders, Biomes, Resources, Features, StartBiasBiomes, StartBiasTerrains, StartBiasRivers, etc.  
  – For example, GameInfo.Ages.lookup(Game.age) returns an object with properties such as AgeType and GenerateDiscoveries (boolean).  
 • Each of the arrays (GameInfo.Maps, GameInfo.Biomes, …) is used to tune parameters.

H. Configuration  
 • getGameValue(key:string): any  
 • getMapValue(key:string): any  
  – Returns values used to tune specific parts of map generation (for example, “DiscoverySiftingType” or “RequestedNaturalWonders”).

I. Data Types and Enums  
 Certain constants (enums) are available and used throughout:  
 • DirectionTypes.NUM_DIRECTION_TYPES (number) – total number of adjacent directions (usually 6, for a hex grid).  
 • PlotTags – an object with numeric properties such as PLOT_TAG_NONE, PLOT_TAG_WATER, PLOT_TAG_ISLAND, PLOT_TAG_EAST_WATER, PLOT_TAG_WEST_WATER, etc.  
 • RiverTypes – e.g. RIVER_NAVIGABLE  
 • ResourceTypes – e.g. ResourceTypes.NO_RESOURCE  
 • DiscoveryActivationTypes – e.g. BASIC, INVESTIGATION, MYTHIC  
 • DiscoveryVisualTypes – numeric effects for discoveries (for example, IMPROVEMENT_RUINS, IMPROVEMENT_WRECKAGE, etc.)

─────────────────────────────  
USAGE NOTES  
─────────────────────────────  
– When writing your own map–generator script you must at least define “requestMapData(initParams)” and “generateMap( )” which the engine will call.  
– Use GameplayMap, TerrainBuilder and FractalBuilder to “carve” land; then use utilities (from map–utilities.js) to tag plots properly.  
– Global parameters in map–globals.js should be used (and tuned if desired) to guarantee uniformity (for example, water–percent, polar rows, etc.).  
– Many routines (such as adding mountains or lakes) are “white–box” and you may call them in any order provided the recalculation steps (AreaBuilder.recalculateAreas, TerrainBuilder.validateAndFixTerrain) are performed frequently after major changes.  
– Debug routines (in map-debug-helpers.js) are useful when testing your map style by viewing an ASCII “sketch” of the landmasses.
– Most functions have a simple signature with numeric parameters (for dimensions, coordinates, weights) or arrays/objects (for sectors, regions, start positions).
– Randomness is provided by TerrainBuilder.getRandomNumber(max, context) so that every call logs the “context” for debugging.

─────────────────────────────  
CONCLUSION  
This API guide covers the functions and globals that a Civ7 map–generator script might use. Although the six different map types (Archipelago, Continents, Continents‑Plus, Fractal, Terra‑Incognita and Shuffle) choose different fractal parameters and orders of operations, they all share this common set of engine services. By understanding the data types (numbers, booleans, objects with numeric fields, arrays) and function usages described above, developers can both customize existing map–scripts and build entirely new map–generation methods.